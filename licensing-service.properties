example.property= I AM THE DEFAULT


spring.jpa.hibernate.ddl-auto=update
spring.jpa.database=POSTGRESQL

eureka.instance.preferIpAddress = true

eureka.client.registerWithEureka = true

eureka.client.fetchRegistry = true

eureka.client.serviceUrl.defaultZone = http://localhost:8070/eureka/

# If you look at these, after .instances. there is a circuitbreaker name (which you can define it in the annotation)
# Whether to expose the configuration into health endpoint
resilience4j.circuitbreaker.instances.licenseService.registerHealthIndicator = true

# closed ring buffer size, it's like an minimum requests on the closed state, before considering to change state
resilience4j.circuitbreaker.instances.licenseService.ringBufferSizeInClosedState = 5

# closed ring buffer size, it's like an minimum requests on the half open state, before considering to change state
resilience4j.circuitbreaker.instances.licenseService.ringBufferSizeInHalfOpenState = 3

# period of time that the circuit breaker remains in the "open" state before transitioning to the "half-open" state.
resilience4j.circuitbreaker.instances.licenseService.waitDurationInOpenState = 10s

# Number of failure rate, before changing the state into open state
resilience4j.circuitbreaker.instances.licenseService.failureRateThreshold = 50

# All of the type of exceptions, which are considered as failures (in the default, all of the exceptions are considered as failures)
resilience4j.circuitbreaker.instances.licenseService.recordExceptions[0]=org.springframework.web.client.HttpServerErrorException
resilience4j.circuitbreaker.instances.licenseService.recordExceptions[1]=java.io.IOException
resilience4j.circuitbreaker.instances.licenseService.recordExceptions[2]=java.util.concurrent.TimeoutException
resilience4j.circuitbreaker.instances.licenseService.recordExceptions[3]=org.springframework.web.client.ResourceAccessException

resilience4j.circuitbreaker.instances.organizationService.registerHealthIndicator = true


resilience4j.circuitbreaker.instances.organizationService.ringBufferSizeInClosedState = 6
resilience4j.circuitbreaker.instances.organizationService.ringBufferSizeInHalfOpenState = 4
resilience4j.circuitbreaker.instances.organizationService.waitDurationInOpenState = 20s
resilience4j.circuitbreaker.instances.organizationService.failureRateThreshold = 60


# You can learn the difference between Semaphore bulkhead and thread pool bulkhead in the main file of licensing service project
# Same as circuit breaker, you can set a name to the bulkhead, and configure it 
# That's why it looks like these. The pattern is resilience4j.bulkhead.instances.<service name>

# Semaphore bulkhead : 
# Maximum amount of time to block the thread when entering bulkhead
resilience4j.bulkhead.instances.bulkheadLicenseService.maxWaitDuration = 0
# Max number concurrent call
resilience4j.bulkhead.instances.bulkheadLicenseService.maxConcurrentCalls = 20

# Thread pool bulkhead : 
# Max number of threads in thread pool
resilience4j.thread-pool-bulkhead.instances.bulkheadLicenseService.maxThreadPoolSize = 10

# Number of threads that will be kept alive, even though there is no tasks
resilience4j.thread-pool-bulkhead.instances.bulkheadLicenseService.coreThreadPoolSize = 5

# Maximum number of requests that can be waiting in the queue when all of the threads are busy
resilience4j.thread-pool-bulkhead.instances.bulkheadLicenseService.queueCapacity = 2

# This sets the duration that excess idle threads in the thread pool will remain alive before being terminated. 
# Here, it's set to 20 milliseconds, meaning if a thread is idle for more than 20 milliseconds, it may be terminated to free up system resources.
resilience4j.thread-pool-bulkhead.instances.bulkheadLicenseService.keepAliveDuration = 1

# This is configuration for retry pattern
# Basically spring will retry the requests despite the error response

# Max number attempts despite the error response
resilience4j.retry.instances.retryLicenseService.maxRetryAttempts = 5

# The duration between attempt
resilience4j.retry.instances.retryLicenseService.waitDuration = 10000

# Type of error that will be reattempt
resilience4j.retry.instances.retryLicenseService.retry-exceptions[0] = java.util.concurrent.TimeoutException

//Part of boostrap.yml omitted for conciseness

resilience4j.ratelimiter.instances.licenseService.timeoutDuration = 1000ms
resilience4j.ratelimiter.instances.licenseService.limitRefreshPeriod = 5000
resilience4j.ratelimiter.instances.licenseService.limitForPeriod = 5
  
    
